// src/codegen.rs
#![allow(dead_code, unused_mut)]

use crate::ast::{
    BinOp, Capability, Expr, Function, Item, Literal, NetPortSpec, Program, Stmt, Type,
};

pub fn generate_rust(program: &Program, _async_mode: bool) -> String {
    let mut w = W::new();

    w.l(r#"#![allow(dead_code, unused_mut)]
// AUTO-GENERATED by NEX codegen. DO NOT EDIT.
//
// v0.2.x: Structured Concurrency (task trees, cancel/join)
// v0.3.x: Capability policies (fs.read globs + net.listen ranges)
"#);

    // ------------------------------
    // Imports
    // ------------------------------
    w.l("use std::cell::RefCell;");
    w.l("use std::collections::{HashMap, VecDeque};");
    w.l("use std::fs;");
    w.l("use std::sync::{Arc, OnceLock, Mutex, atomic::{AtomicBool, AtomicU64, Ordering}};");
    w.l("use std::time::Duration;");
    w.l("");

    // ------------------------------
    // Capability allowlists (defense-in-depth)
    // ------------------------------
    let (fs_globs, net_ports, net_port_ranges) = collect_cap_allowlists(program);

    w.l("static __NEX_FS_READ_ALLOW: &[&str] = &[");
    w.ind += 1;
    for g in fs_globs {
        w.l(&format!("{:?},", g));
    }
    w.ind = w.ind.saturating_sub(1);
    w.l("];");
    w.l("");

    w.l("static __NEX_NET_LISTEN_ALLOW: &[i64] = &[");
    w.ind += 1;
    for p in &net_ports {
        w.l(&format!("{},", p));
    }
    w.ind = w.ind.saturating_sub(1);
    w.l("];");
    w.l("");

    w.l("static __NEX_NET_LISTEN_RANGE_ALLOW: &[(i64, i64)] = &[");
    w.ind += 1;
    for (a, b) in &net_port_ranges {
        w.l(&format!("({}, {}),", a, b));
    }
    w.ind = w.ind.saturating_sub(1);
    w.l("];");
    w.l("");

    // ------------------------------
    // v0.3.x helpers: path normalization + glob matching + allow checks
    // ------------------------------
    w.l("fn __nex_normalize_rel_path(input: &str) -> Option<String> {");
    w.ind += 1;
    w.l("// Normalize relative paths, deny traversal and absolute/drive paths.");
    w.l("let mut x = input.trim().replace('\\\\', \"/\");");
    w.l("while x.starts_with(\"./\") { x = x[2..].to_string(); }");
    w.l("if x.starts_with('/') { return None; }");
    w.l("if x.contains(':') { return None; }");
    w.l("let mut parts: Vec<&str> = Vec::new();");
    w.l("for seg in x.split('/') {");
    w.ind += 1;
    w.l("if seg.is_empty() || seg == \".\" { continue; }");
    w.l("if seg == \"..\" { return None; }");
    w.l("parts.push(seg);");
    w.ind = w.ind.saturating_sub(1);
    w.l("}");
    w.l("if parts.is_empty() { return None; }");
    w.l("Some(parts.join(\"/\"))");
    w.ind = w.ind.saturating_sub(1);
    w.l("}");
    w.l("");

    // Glob matcher supporting '*' and '?'.
    w.l("fn __nex_glob_match(pat: &str, text: &str) -> bool {");
    w.ind += 1;
    w.l("let (mut i, mut j) = (0usize, 0usize);");
    w.l("let mut star_i: Option<usize> = None;");
    w.l("let mut star_j: usize = 0;");
    w.l("let pb = pat.as_bytes();");
    w.l("let tb = text.as_bytes();");
    w.l("while j < tb.len() {");
    w.ind += 1;
    w.l("if i < pb.len() && (pb[i] == tb[j] || pb[i] == b'?') {");
    w.ind += 1;
    w.l("i += 1; j += 1;");
    w.ind = w.ind.saturating_sub(1);
    w.l("} else if i < pb.len() && pb[i] == b'*' {");
    w.ind += 1;
    w.l("star_i = Some(i);");
    w.l("star_j = j;");
    w.l("i += 1;");
    w.ind = w.ind.saturating_sub(1);
    w.l("} else if let Some(si) = star_i {");
    w.ind += 1;
    w.l("i = si + 1;");
    w.l("star_j += 1;");
    w.l("j = star_j;");
    w.ind = w.ind.saturating_sub(1);
    w.l("} else {");
    w.ind += 1;
    w.l("return false;");
    w.ind = w.ind.saturating_sub(1);
    w.l("}");
    w.ind = w.ind.saturating_sub(1);
    w.l("}");
    w.l("while i < pb.len() && pb[i] == b'*' { i += 1; }");
    w.l("i == pb.len()");
    w.ind = w.ind.saturating_sub(1);
    w.l("}");
    w.l("");

    // FS allow check (define exactly once)
    w.l("fn __nex_fs_read_allowed(raw_path: &str) -> bool {");
    w.ind += 1;
    w.l("let norm_path = match __nex_normalize_rel_path(raw_path) {");
    w.ind += 1;
    w.l("Some(p) => p,");
    w.l("None => return false,");
    w.ind = w.ind.saturating_sub(1);
    w.l("};");
    w.l("if __NEX_FS_READ_ALLOW.iter().any(|g| *g == \"*\") { return true; }");
    w.l("for g in __NEX_FS_READ_ALLOW.iter() {");
    w.ind += 1;
    w.l("let gg = g.trim();");
    w.l("if gg == \"*\" { return true; }");
    w.l("let norm_glob = match __nex_normalize_rel_path(gg) {");
    w.ind += 1;
    w.l("Some(x) => x,");
    w.l("None => continue,");
    w.ind = w.ind.saturating_sub(1);
    w.l("};");
    w.l("if __nex_glob_match(&norm_glob, &norm_path) { return true; }");
    w.ind = w.ind.saturating_sub(1);
    w.l("}");
    w.l("false");
    w.ind = w.ind.saturating_sub(1);
    w.l("}");
    w.l("");

    // net.listen allowed if in single list OR any range
    w.l("fn __nex_net_listen_allowed(port: i64) -> bool {");
    w.ind += 1;
    w.l("let single_ok = __NEX_NET_LISTEN_ALLOW.iter().any(|p| *p == port);");
    w.l(
        "let range_ok = __NEX_NET_LISTEN_RANGE_ALLOW.iter().any(|(a,b)| port >= *a && port <= *b);",
    );
    w.l("single_ok || range_ok");
    w.ind = w.ind.saturating_sub(1);
    w.l("}");
    w.l("");

    // ------------------------------
    // v0.2 runtime: task ids + registry + cancellation tokens
    // ------------------------------
    w.l("type __NexTaskId = u64;");
    w.l("");

    w.l("#[derive(Clone, Debug)]");
    w.l("struct __NexCancelToken { cancelled: Arc<AtomicBool> }");
    w.l("impl __NexCancelToken {");
    w.ind += 1;
    w.l("fn new() -> Self { Self { cancelled: Arc::new(AtomicBool::new(false)) } }");
    w.l("fn cancel(&self) { self.cancelled.store(true, Ordering::SeqCst); }");
    w.l("fn is_cancelled(&self) -> bool { self.cancelled.load(Ordering::SeqCst) }");
    w.ind = w.ind.saturating_sub(1);
    w.l("}");
    w.l("");

    w.l("#[derive(Debug)]");
    w.l("struct __NexTask { id: __NexTaskId, handle: Option<std::thread::JoinHandle<()>>, token: __NexCancelToken }");
    w.l("");

    w.l("#[derive(Clone, Debug)]");
    w.l("struct __NexTaskMeta { parent: Option<__NexTaskId>, children: Vec<__NexTaskId>, token: __NexCancelToken }");
    w.l("");

    w.l("static __NEX_TASK_ID_GEN: AtomicU64 = AtomicU64::new(1);");
    w.l("static __NEX_TASK_REGISTRY: OnceLock<Mutex<HashMap<__NexTaskId, __NexTaskMeta>>> = OnceLock::new();");
    w.l("");

    w.l("thread_local! {");
    w.ind += 1;
    w.l("static __NEX_CURRENT_TASK_ID: RefCell<__NexTaskId> = RefCell::new(0);");
    w.l("static __NEX_CURRENT_TOKEN: RefCell<__NexCancelToken> = RefCell::new(__NexCancelToken::new());");
    w.ind = w.ind.saturating_sub(1);
    w.l("}");
    w.l("");

    w.l("fn __nex_registry() -> &'static Mutex<HashMap<__NexTaskId, __NexTaskMeta>> {");
    w.ind += 1;
    w.l("__NEX_TASK_REGISTRY.get_or_init(|| {");
    w.ind += 1;
    w.l("let mut map = HashMap::new();");
    w.l("map.insert(0, __NexTaskMeta { parent: None, children: Vec::new(), token: __NexCancelToken::new() });");
    w.l("Mutex::new(map)");
    w.ind = w.ind.saturating_sub(1);
    w.l("})");
    w.ind = w.ind.saturating_sub(1);
    w.l("}");
    w.l("");

    w.l("fn __nex_get_current_task_id() -> __NexTaskId { __NEX_CURRENT_TASK_ID.with(|c| *c.borrow()) }");
    w.l("fn __nex_set_current_task_id(id: __NexTaskId) { __NEX_CURRENT_TASK_ID.with(|c| *c.borrow_mut() = id); }");
    w.l("fn __nex_get_current_token() -> __NexCancelToken { __NEX_CURRENT_TOKEN.with(|t| t.borrow().clone()) }");
    w.l("fn __nex_set_current_token(tok: __NexCancelToken) { __NEX_CURRENT_TOKEN.with(|t| *t.borrow_mut() = tok); }");
    w.l("");

    w.l("fn __nex_alloc_task_id() -> __NexTaskId { __NEX_TASK_ID_GEN.fetch_add(1, Ordering::SeqCst) }");
    w.l("");

    w.l("fn __nex_get_token(id: __NexTaskId) -> __NexCancelToken {");
    w.ind += 1;
    w.l("let reg = __nex_registry().lock().unwrap();");
    w.l("reg.get(&id).map(|m| m.token.clone()).unwrap_or_else(__NexCancelToken::new)");
    w.ind = w.ind.saturating_sub(1);
    w.l("}");
    w.l("");

    // Spawn child (structured)
    w.l("fn __nex_spawn_child<F>(f: F) -> __NexTask");
    w.l("where F: FnOnce() + Send + 'static {");
    w.ind += 1;
    w.l("let parent_id = __nex_get_current_task_id();");
    w.l("let child_id = __nex_alloc_task_id();");
    w.l("let child_tok = __NexCancelToken::new();");
    w.l("{");
    w.ind += 1;
    w.l("let mut reg = __nex_registry().lock().unwrap();");
    w.l("reg.insert(child_id, __NexTaskMeta { parent: Some(parent_id), children: Vec::new(), token: child_tok.clone() });");
    w.l("if let Some(pm) = reg.get_mut(&parent_id) { pm.children.push(child_id); }");
    w.ind = w.ind.saturating_sub(1);
    w.l("}");
    w.l("let handle = std::thread::spawn(move || {");
    w.ind += 1;
    w.l("__nex_set_current_task_id(child_id);");
    w.l("__nex_set_current_token(child_tok.clone());");
    w.l("f();");
    w.ind = w.ind.saturating_sub(1);
    w.l("});");
    w.l("__NexTask { id: child_id, handle: Some(handle), token: __nex_get_token(child_id) }");
    w.ind = w.ind.saturating_sub(1);
    w.l("}");
    w.l("");

    // Cancel subtree
    w.l("fn __nex_cancel_subtree(root: __NexTaskId) {");
    w.ind += 1;
    w.l("let mut q: VecDeque<__NexTaskId> = VecDeque::new();");
    w.l("q.push_back(root);");
    w.l("while let Some(id) = q.pop_front() {");
    w.ind += 1;
    w.l("let children = {");
    w.ind += 1;
    w.l("let reg = __nex_registry().lock().unwrap();");
    w.l("reg.get(&id).map(|m| m.children.clone()).unwrap_or_default()");
    w.ind = w.ind.saturating_sub(1);
    w.l("};");
    w.l("for c in children { q.push_back(c); }");
    w.l("__nex_get_token(id).cancel();");
    w.ind = w.ind.saturating_sub(1);
    w.l("}");
    w.ind = w.ind.saturating_sub(1);
    w.l("}");
    w.l("");

    // Join subtree (placeholder; join is via handles you hold)
    w.l("fn __nex_join_subtree(_root: __NexTaskId) { }");
    w.l("");

    w.l("fn cancelled() -> bool { __nex_get_current_token().is_cancelled() }");
    w.l("");

    w.l("fn join(t: __NexTask) { if let Some(h) = t.handle { let _ = h.join(); } }");
    w.l("");

    w.l("fn cancel(t: &__NexTask) { __nex_cancel_subtree(t.id); }");
    w.l("");

    w.l("fn sleep_ms(ms: i64) { std::thread::sleep(Duration::from_millis(ms as u64)); }");
    w.l("");

    // fs.read wrapper
    w.l("fn read_file(path: &str) -> String {");
    w.ind += 1;
    w.l("if !__nex_fs_read_allowed(path) {");
    w.ind += 1;
    w.l("panic!(\"NEX runtime: fs.read not allowed: {}\", path);");
    w.ind = w.ind.saturating_sub(1);
    w.l("}");
    w.l("fs::read_to_string(path).unwrap_or_else(|_| \"\".to_string())");
    w.ind = w.ind.saturating_sub(1);
    w.l("}");
    w.l("");

    // net.listen wrapper (dummy)
    w.l("fn listen_http(port: i64) {");
    w.ind += 1;
    w.l("if !__nex_net_listen_allowed(port) {");
    w.ind += 1;
    w.l("panic!(\"NEX runtime: net.listen not allowed: {}\", port);");
    w.ind = w.ind.saturating_sub(1);
    w.l("}");
    w.l("// Placeholder: real network runtime comes later.");
    w.ind = w.ind.saturating_sub(1);
    w.l("}");
    w.l("");

    // print wrapper
    w.l("fn print(s: String) { println!(\"{}\", s); }");
    w.l("");

    // Entry shim
    w.l("fn main() {");
    w.ind += 1;
    w.l("__nex_set_current_task_id(0);");
    w.l("__nex_set_current_token(__NexCancelToken::new());");
    w.l("let res = std::panic::catch_unwind(|| { __nex_user_main(); });");
    w.l("match res {");
    w.ind += 1;
    w.l("Ok(_) => {}");
    w.l("Err(_) => {");
    w.ind += 1;
    w.l("__nex_cancel_subtree(0);");
    w.l("__nex_join_subtree(0);");
    w.l("panic!(\"NEX runtime: user panic\");");
    w.ind = w.ind.saturating_sub(1);
    w.l("}");
    w.ind = w.ind.saturating_sub(1);
    w.l("}");
    w.ind = w.ind.saturating_sub(1);
    w.l("}");
    w.l("");

    // ------------------------------
    // User functions
    // ------------------------------
    for it in &program.items {
        if let Item::Function(f) = it {
            emit_function(&mut w, f);
            w.l("");
        }
    }

    w.out
}

fn collect_cap_allowlists(program: &Program) -> (Vec<String>, Vec<i64>, Vec<(i64, i64)>) {
    let mut fs_globs: Vec<String> = Vec::new();
    let mut net_ports: Vec<i64> = Vec::new();
    let mut net_port_ranges: Vec<(i64, i64)> = Vec::new();

    for it in &program.items {
        if let Item::Capability(c) = it {
            match &c.cap {
                Capability::FsRead { glob } => fs_globs.push(glob.clone()),
                Capability::NetListen { range } => match range {
                    NetPortSpec::Single(p) => net_ports.push(*p),
                    NetPortSpec::Range(a, b) => net_port_ranges.push((*a, *b)),
                },
            }
        }
    }

    fs_globs.sort();
    fs_globs.dedup();

    net_ports.sort();
    net_ports.dedup();

    net_port_ranges.sort();
    net_port_ranges.dedup();

    (fs_globs, net_ports, net_port_ranges)
}

fn emit_function(w: &mut W, f: &Function) {
    let rust_name = if f.name == "main" {
        "__nex_user_main"
    } else {
        &f.name
    };

    w.l(&format!(
        "fn {}({}){} {{",
        rust_name,
        emit_params(&f.params),
        emit_ret(&f.return_type)
    ));
    w.ind += 1;

    for s in &f.body.stmts {
        emit_stmt(w, s);
    }

    if f.return_type.is_none() {
        w.l("()");
    }

    w.ind = w.ind.saturating_sub(1);
    w.l("}");
}

fn emit_params(params: &[crate::ast::Param]) -> String {
    params
        .iter()
        .map(|p| format!("{}: {}", p.name, rust_type(&p.ty)))
        .collect::<Vec<_>>()
        .join(", ")
}

fn emit_ret(rt: &Option<Type>) -> String {
    match rt {
        None => "".to_string(),
        Some(t) => format!(" -> {}", rust_type(t)),
    }
}

fn rust_type(t: &Type) -> String {
    match t {
        Type::I32 => "i64".to_string(),
        Type::F32 => "f64".to_string(),
        Type::Bool => "bool".to_string(),
        Type::String => "String".to_string(),
        Type::Task => "__NexTask".to_string(),
        Type::Named(n) => n.clone(),
    }
}

fn emit_stmt(w: &mut W, s: &Stmt) {
    match s {
        Stmt::Let { name, ty, value } => {
            if let Some(t) = ty {
                w.l(&format!(
                    "let mut {}: {} = {};",
                    name,
                    rust_type(t),
                    emit_expr(value)
                ));
            } else {
                w.l(&format!("let mut {} = {};", name, emit_expr(value)));
            }
        }
        Stmt::Return(e) => {
            if let Some(ex) = e {
                w.l(&format!("return {};", emit_expr(ex)));
            } else {
                w.l("return;");
            }
        }
        Stmt::Expr(e) => w.l(&format!("{};", emit_expr(e))),
        Stmt::If {
            cond,
            then_block,
            else_block,
        } => {
            w.l(&format!("if {} {{", emit_expr(cond)));
            w.ind += 1;
            for st in &then_block.stmts {
                emit_stmt(w, st);
            }
            w.ind = w.ind.saturating_sub(1);
            w.l("}");
            if let Some(eb) = else_block {
                w.l("else {");
                w.ind += 1;
                for st in &eb.stmts {
                    emit_stmt(w, st);
                }
                w.ind = w.ind.saturating_sub(1);
                w.l("}");
            }
        }
        Stmt::Loop(b) => {
            w.l("loop {");
            w.ind += 1;
            for st in &b.stmts {
                emit_stmt(w, st);
            }
            w.ind = w.ind.saturating_sub(1);
            w.l("}");
        }
        Stmt::Defer(b) => {
            w.l("{");
            w.ind += 1;
            for st in &b.stmts {
                emit_stmt(w, st);
            }
            w.ind = w.ind.saturating_sub(1);
            w.l("}");
        }
    }
}

fn emit_expr(e: &Expr) -> String {
    match e {
        Expr::Literal(l) => match l {
            Literal::Int(i) => format!("{}", i),
            Literal::Float(f) => format!("{}", f),
            Literal::Bool(b) => format!("{}", b),
            Literal::String(s) => format!("{:?}.to_string()", s),
        },
        Expr::Variable(v) => v.clone(),
        Expr::Call { func, args, .. } => {
            let rust_fn = match func.as_str() {
                "print" => "print",
                "fs.read" | "read_file" => "read_file",
                "net.listen" | "listen_http" => "listen_http",
                "sleep_ms" => "sleep_ms",
                "join" => "join",
                "cancel" => "cancel",
                "cancelled" => "cancelled",
                _ => func,
            };
            let rendered = args.iter().map(emit_expr).collect::<Vec<_>>().join(", ");
            format!("{}({})", rust_fn, rendered)
        }
        Expr::BinaryOp { left, op, right } => {
            let o = match op {
                BinOp::Add => "+",
                BinOp::Sub => "-",
                BinOp::Mul => "*",
                BinOp::Div => "/",
                BinOp::Eq => "==",
                BinOp::Ne => "!=",
                BinOp::Lt => "<",
                BinOp::Le => "<=",
                BinOp::Gt => ">",
                BinOp::Ge => ">=",
            };
            format!("({} {} {})", emit_expr(left), o, emit_expr(right))
        }
        Expr::If {
            cond,
            then_block,
            else_block,
        } => {
            let mut out = String::new();
            out.push_str(&format!("(if {} ", emit_expr(cond)));
            out.push_str("{ ");
            for st in &then_block.stmts {
                out.push_str(&format!("{}; ", emit_stmt_to_inline(st)));
            }
            out.push_str(" }");
            if let Some(eb) = else_block {
                out.push_str(" else { ");
                for st in &eb.stmts {
                    out.push_str(&format!("{}; ", emit_stmt_to_inline(st)));
                }
                out.push_str(" }");
            }
            out.push(')');
            out
        }
        Expr::Block(b) => {
            let mut out = String::new();
            out.push_str("{ ");
            for st in &b.stmts {
                out.push_str(&format!("{}; ", emit_stmt_to_inline(st)));
            }
            out.push_str(" }");
            out
        }
        Expr::Spawn { block, .. } => {
            let mut body = String::new();
            body.push_str("{ ");
            for st in &block.stmts {
                body.push_str(&format!("{}; ", emit_stmt_to_inline(st)));
            }
            body.push_str(" }");
            format!("__nex_spawn_child(|| {})", body)
        }
    }
}

fn emit_stmt_to_inline(s: &Stmt) -> String {
    match s {
        Stmt::Let { name, ty, value } => {
            if let Some(t) = ty {
                format!("let mut {}: {} = {}", name, rust_type(t), emit_expr(value))
            } else {
                format!("let mut {} = {}", name, emit_expr(value))
            }
        }
        Stmt::Return(e) => {
            if let Some(ex) = e {
                format!("return {}", emit_expr(ex))
            } else {
                "return".to_string()
            }
        }
        Stmt::Expr(e) => emit_expr(e),
        Stmt::If { .. } => "{ /* if as stmt */ }".to_string(),
        Stmt::Loop(_) => "{ /* loop as stmt */ }".to_string(),
        Stmt::Defer(_) => "{ /* defer as stmt */ }".to_string(),
    }
}

// Tiny writer
struct W {
    out: String,
    ind: usize,
}

impl W {
    fn new() -> Self {
        Self {
            out: String::new(),
            ind: 0,
        }
    }

    fn l(&mut self, s: &str) {
        for _ in 0..self.ind {
            self.out.push_str("    ");
        }
        self.out.push_str(s);
        self.out.push('\n');
    }
}
