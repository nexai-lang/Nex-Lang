// src/codegen.rs
#![allow(dead_code, unused_mut)]

use crate::ast::{BinOp, Capability, Expr, Function, Item, Literal, Program, Stmt, Type};

pub fn generate_rust(program: &Program, _async_mode: bool) -> String {
    let mut w = W::new();

    w.l("#![allow(dead_code, unused_mut)]
// AUTO-GENERATED by NEX codegen. DO NOT EDIT.");
    w.l("// v0.2.0: Structured Concurrency (Task Trees)");
    w.l("// - Step 0.2.1: Task Context + Registry");
    w.l("// - Step 0.2.3: Cancellation Propagation (subtree cancel)");
    w.l("// - Step 0.2.4: Deterministic Cleanup (auto-cancel + join children on exit)");
    w.l("");

    // ------------------------------
    // Imports
    // ------------------------------
    w.l("use std::cell::RefCell;");
    w.l("use std::collections::{HashMap, VecDeque};");
    w.l("use std::fs;");
    w.l("use std::path::Path;");
    w.l("use std::sync::{Arc, OnceLock, Mutex, atomic::{AtomicBool, AtomicU64, Ordering}};");
    w.l("use std::time::Duration;");
    w.l("");

    // ------------------------------
    // Capability allowlists (defense-in-depth)
    // ------------------------------
    let (fs_globs, net_ports) = collect_cap_allowlists(program);

    w.l("static __NEX_FS_READ_ALLOW: &[&str] = &[");
    w.ind += 1;
    for g in fs_globs {
        w.l(&format!("{:?},", g));
    }
    w.ind = w.ind.saturating_sub(1);
    w.l("];");
    w.l("");

    w.l("static __NEX_NET_LISTEN_ALLOW: &[i64] = &[");
    w.ind += 1;
    for p in net_ports {
        w.l(&format!("{},", p));
    }
    w.ind = w.ind.saturating_sub(1);
    w.l("];");
    w.l("");

    w.l("fn __nex_fs_read_allowed(path: &str) -> bool {");
    w.ind += 1;
    w.l("__NEX_FS_READ_ALLOW.iter().any(|g| *g == \"*\" || *g == path)");
    w.ind = w.ind.saturating_sub(1);
    w.l("}");
    w.l("");

    w.l("fn __nex_net_listen_allowed(port: i64) -> bool {");
    w.ind += 1;
    w.l("__NEX_NET_LISTEN_ALLOW.iter().any(|p| *p == port)");
    w.ind = w.ind.saturating_sub(1);
    w.l("}");
    w.l("");

    // ------------------------------
    // Cancellation runtime (base)
    // ------------------------------
    w.l("#[allow(dead_code)]");
    w.l("#[derive(Clone, Debug)]");
    w.l("struct __NexCancelToken { flag: Arc<AtomicBool> }");
    w.l("impl __NexCancelToken {");
    w.ind += 1;
    w.l("fn new() -> Self { Self { flag: Arc::new(AtomicBool::new(false)) } }");
    w.l("fn cancel(&self) { self.flag.store(true, Ordering::SeqCst); }");
    w.l("fn cancelled(&self) -> bool { self.flag.load(Ordering::SeqCst) }");
    w.ind = w.ind.saturating_sub(1);
    w.l("}");
    w.l("");

    w.l("static __NEX_ROOT_TOKEN: OnceLock<__NexCancelToken> = OnceLock::new();");
    w.l("thread_local! {");
    w.l("    static __NEX_CURRENT_TOKEN: RefCell<__NexCancelToken> = RefCell::new(__NexCancelToken::new());");
    w.l("}");
    w.l("");

    w.l("fn __nex_install_root_token() {");
    w.ind += 1;
    w.l("let root = __NEX_ROOT_TOKEN.get_or_init(__NexCancelToken::new).clone();");
    w.l("__NEX_CURRENT_TOKEN.with(|t| *t.borrow_mut() = root);");
    w.ind = w.ind.saturating_sub(1);
    w.l("}");
    w.l("");

    w.l("fn __nex_set_current_token(tok: __NexCancelToken) {");
    w.ind += 1;
    w.l("__NEX_CURRENT_TOKEN.with(|t| *t.borrow_mut() = tok);");
    w.ind = w.ind.saturating_sub(1);
    w.l("}");
    w.l("");

    w.l("fn __nex_cancelled() -> bool {");
    w.ind += 1;
    w.l("__NEX_CURRENT_TOKEN.with(|t| t.borrow().cancelled())");
    w.ind = w.ind.saturating_sub(1);
    w.l("}");
    w.l("");

    // ------------------------------
    // Task runtime (Structured Concurrency)
    // ------------------------------
    w.l("type __NexTaskId = u64;");
    w.l("static __NEX_TASK_ID_GEN: AtomicU64 = AtomicU64::new(1);");
    w.l("");

    // Registry stores parent/children + token + handle for deterministic subtree join.
    w.l("#[allow(dead_code)]");
    w.l("struct __NexTaskMeta {");
    w.ind += 1;
    w.l("parent: Option<__NexTaskId>,");
    w.l("children: Vec<__NexTaskId>,");
    w.l("token: __NexCancelToken,");
    w.l("handle: Option<std::thread::JoinHandle<()>>,"); // moved out on join
    w.ind = w.ind.saturating_sub(1);
    w.l("}");
    w.l("");

    w.l("static __NEX_TASK_REGISTRY: OnceLock<Mutex<HashMap<__NexTaskId, __NexTaskMeta>>> = OnceLock::new();");
    w.l("");

    w.l("fn __nex_registry() -> &'static Mutex<HashMap<__NexTaskId, __NexTaskMeta>> {");
    w.ind += 1;
    w.l("__NEX_TASK_REGISTRY.get_or_init(|| Mutex::new(HashMap::new()))");
    w.ind = w.ind.saturating_sub(1);
    w.l("}");
    w.l("");

    w.l("thread_local! {");
    w.l("    static __NEX_CURRENT_TASK_ID: RefCell<__NexTaskId> = RefCell::new(0);");
    w.l("}");
    w.l("");

    w.l("fn __nex_get_current_task_id() -> __NexTaskId {");
    w.ind += 1;
    w.l("__NEX_CURRENT_TASK_ID.with(|id| *id.borrow())");
    w.ind = w.ind.saturating_sub(1);
    w.l("}");
    w.l("");

    w.l("fn __nex_set_current_task_id(id: __NexTaskId) {");
    w.ind += 1;
    w.l("__NEX_CURRENT_TASK_ID.with(|cur| *cur.borrow_mut() = id);");
    w.ind = w.ind.saturating_sub(1);
    w.l("}");
    w.l("");

    // Task handle exposed to NEX programs (id-only; registry owns join handles)
    w.l("#[derive(Clone, Copy, Debug)]");
    w.l("struct __NexTask { id: __NexTaskId }");
    w.l("");

    // ---- Deterministic cleanup guard (Step 0.2.4)
    w.l("struct __NexTaskScopeGuard { task_id: __NexTaskId }");
    w.l("impl __NexTaskScopeGuard {");
    w.ind += 1;
    w.l("fn new(task_id: __NexTaskId) -> Self { Self { task_id } }");
    w.ind = w.ind.saturating_sub(1);
    w.l("}");
    w.l("impl Drop for __NexTaskScopeGuard {");
    w.ind += 1;
    w.l("fn drop(&mut self) {");
    w.ind += 1;
    w.l("// On task exit: cancel + join all remaining children (subtree), deterministically.");
    w.l("__nex_cancel_children_subtree(self.task_id);");
    w.l("__nex_join_children_subtree(self.task_id);");
    w.ind = w.ind.saturating_sub(1);
    w.l("}");
    w.ind = w.ind.saturating_sub(1);
    w.l("}");
    w.l("");

    // Install root context (task 0)
    w.l("fn __nex_install_root_task_context() {");
    w.ind += 1;
    w.l("__nex_install_root_token();");
    w.l("let root_id: __NexTaskId = 0;");
    w.l("__nex_set_current_task_id(root_id);");
    w.l("let root_tok = __NEX_CURRENT_TOKEN.with(|t| t.borrow().clone());");
    w.l("let mut reg = __nex_registry().lock().expect(\"NEX runtime: TASK_REGISTRY mutex poisoned\");");
    w.l("reg.entry(root_id).or_insert(__NexTaskMeta { parent: None, children: Vec::new(), token: root_tok, handle: None });");
    w.ind = w.ind.saturating_sub(1);
    w.l("}");
    w.l("");

    // ---- Subtree traversal helpers
    // Deterministic: children are visited in insertion order.
    // We build a post-order list: children first, then parent.
    w.l("fn __nex_collect_subtree_postorder(root: __NexTaskId) -> Vec<__NexTaskId> {");
    w.ind += 1;
    w.l("let reg = __nex_registry().lock().expect(\"NEX runtime: TASK_REGISTRY mutex poisoned\");");
    w.l("let mut out: Vec<__NexTaskId> = Vec::new();");
    w.l("fn dfs(id: __NexTaskId, reg: &HashMap<__NexTaskId, __NexTaskMeta>, out: &mut Vec<__NexTaskId>) {");
    w.ind += 1;
    w.l("if let Some(m) = reg.get(&id) {");
    w.ind += 1;
    w.l("for &c in &m.children { dfs(c, reg, out); }");
    w.l("out.push(id);");
    w.ind = w.ind.saturating_sub(1);
    w.l("} else {");
    w.ind += 1;
    w.l("// If missing, still include the id to keep behavior stable.");
    w.l("out.push(id);");
    w.ind = w.ind.saturating_sub(1);
    w.l("}");
    w.ind = w.ind.saturating_sub(1);
    w.l("}");
    w.ind = w.ind.saturating_sub(1);
    w.l("dfs(root, &reg, &mut out);");
    w.l("out");
    w.ind = w.ind.saturating_sub(1);
    w.l("}");
    w.l("");

    w.l("fn __nex_collect_children_subtree_postorder(parent: __NexTaskId) -> Vec<__NexTaskId> {");
    w.ind += 1;
    w.l("let reg = __nex_registry().lock().expect(\"NEX runtime: TASK_REGISTRY mutex poisoned\");");
    w.l("let mut out: Vec<__NexTaskId> = Vec::new();");
    w.l("if let Some(m) = reg.get(&parent) {");
    w.ind += 1;
    w.l("fn dfs(id: __NexTaskId, reg: &HashMap<__NexTaskId, __NexTaskMeta>, out: &mut Vec<__NexTaskId>) {");
    w.ind += 1;
    w.l("if let Some(m) = reg.get(&id) {");
    w.ind += 1;
    w.l("for &c in &m.children { dfs(c, reg, out); }");
    w.l("out.push(id);");
    w.ind = w.ind.saturating_sub(1);
    w.l("} else { out.push(id); }");
    w.ind = w.ind.saturating_sub(1);
    w.l("}");
    w.ind = w.ind.saturating_sub(1);
    w.l("for &c in &m.children { dfs(c, &reg, &mut out); }");
    w.ind = w.ind.saturating_sub(1);
    w.l("}");
    w.l("out");
    w.ind = w.ind.saturating_sub(1);
    w.l("}");
    w.l("");

    // ---- Step 0.2.3: cancel propagation
    w.l("fn __nex_cancel_subtree(root: __NexTaskId) {");
    w.ind += 1;
    w.l("let ids = __nex_collect_subtree_postorder(root);");
    w.l("// Cancel tokens (no need to hold the lock while calling cancel)");
    w.l("for id in ids {");
    w.ind += 1;
    w.l("let tok_opt = {");
    w.ind += 1;
    w.l("let reg = __nex_registry().lock().expect(\"NEX runtime: TASK_REGISTRY mutex poisoned\");");
    w.l("reg.get(&id).map(|m| m.token.clone())");
    w.ind = w.ind.saturating_sub(1);
    w.l("};");
    w.l("if let Some(tok) = tok_opt { tok.cancel(); }");
    w.ind = w.ind.saturating_sub(1);
    w.l("}");
    w.ind = w.ind.saturating_sub(1);
    w.l("}");
    w.l("");

    w.l("fn __nex_cancel_children_subtree(parent: __NexTaskId) {");
    w.ind += 1;
    w.l("let ids = __nex_collect_children_subtree_postorder(parent);");
    w.l("for id in ids {");
    w.ind += 1;
    w.l("let tok_opt = {");
    w.ind += 1;
    w.l("let reg = __nex_registry().lock().expect(\"NEX runtime: TASK_REGISTRY mutex poisoned\");");
    w.l("reg.get(&id).map(|m| m.token.clone())");
    w.ind = w.ind.saturating_sub(1);
    w.l("};");
    w.l("if let Some(tok) = tok_opt { tok.cancel(); }");
    w.ind = w.ind.saturating_sub(1);
    w.l("}");
    w.ind = w.ind.saturating_sub(1);
    w.l("}");
    w.l("");

    // ---- Join helpers (Step 0.2.3 semantics: join waits for subtree completion)
    w.l("fn __nex_join_subtree(root: __NexTaskId) {");
    w.ind += 1;
    w.l("let ids = __nex_collect_subtree_postorder(root);");
    w.l("for id in ids {");
    w.ind += 1;
    w.l("let handle_opt = {");
    w.ind += 1;
    w.l("let mut reg = __nex_registry().lock().expect(\"NEX runtime: TASK_REGISTRY mutex poisoned\");");
    w.l("reg.get_mut(&id).and_then(|m| m.handle.take())");
    w.ind = w.ind.saturating_sub(1);
    w.l("};");
    w.l("if let Some(h) = handle_opt { let _ = h.join(); }");
    w.ind = w.ind.saturating_sub(1);
    w.l("}");
    w.ind = w.ind.saturating_sub(1);
    w.l("}");
    w.l("");

    w.l("fn __nex_join_children_subtree(parent: __NexTaskId) {");
    w.ind += 1;
    w.l("let ids = __nex_collect_children_subtree_postorder(parent);");
    w.l("for id in ids {");
    w.ind += 1;
    w.l("let handle_opt = {");
    w.ind += 1;
    w.l("let mut reg = __nex_registry().lock().expect(\"NEX runtime: TASK_REGISTRY mutex poisoned\");");
    w.l("reg.get_mut(&id).and_then(|m| m.handle.take())");
    w.ind = w.ind.saturating_sub(1);
    w.l("};");
    w.l("if let Some(h) = handle_opt { let _ = h.join(); }");
    w.ind = w.ind.saturating_sub(1);
    w.l("}");
    w.ind = w.ind.saturating_sub(1);
    w.l("}");
    w.l("");

    // ---- Structured spawn (Step 0.2.1 + handles stored for subtree join)
    w.l("fn __nex_spawn_child<F>(f: F) -> __NexTask");
    w.l("where");
    w.l("    F: FnOnce() + Send + 'static,");
    w.l("{");
    w.ind += 1;

    w.l("let _root = __NEX_ROOT_TOKEN.get_or_init(__NexCancelToken::new).clone();");
    w.l("let parent_id = __nex_get_current_task_id();");
    w.l("let child_id = __NEX_TASK_ID_GEN.fetch_add(1, Ordering::SeqCst);");
    w.l("let child_token = __NexCancelToken::new();");
    w.l("let tok_for_thread = child_token.clone();");

    // Register child BEFORE spawn (handle filled in after spawn)
    w.l("{");
    w.ind += 1;
    w.l("let mut reg = __nex_registry().lock().expect(\"NEX runtime: TASK_REGISTRY mutex poisoned\");");
    w.l("reg.entry(parent_id).or_insert(__NexTaskMeta { parent: None, children: Vec::new(), token: __NexCancelToken::new(), handle: None });");
    w.l("reg.insert(child_id, __NexTaskMeta { parent: Some(parent_id), children: Vec::new(), token: child_token.clone(), handle: None });");
    w.l("if let Some(p) = reg.get_mut(&parent_id) { p.children.push(child_id); }");
    w.ind = w.ind.saturating_sub(1);
    w.l("}");

    w.l("let handle = std::thread::spawn(move || {");
    w.ind += 1;
    w.l("__nex_set_current_task_id(child_id);");
    w.l("__nex_set_current_token(tok_for_thread);");
    w.l("let _scope = __NexTaskScopeGuard::new(child_id);");
    w.l("f();");
    w.ind = w.ind.saturating_sub(1);
    w.l("});");

    // Store handle into registry so subtree join can work
    w.l("{");
    w.ind += 1;
    w.l("let mut reg = __nex_registry().lock().expect(\"NEX runtime: TASK_REGISTRY mutex poisoned\");");
    w.l("if let Some(m) = reg.get_mut(&child_id) { m.handle = Some(handle); }");
    w.ind = w.ind.saturating_sub(1);
    w.l("}");

    w.l("__NexTask { id: child_id }");

    w.ind = w.ind.saturating_sub(1);
    w.l("}");
    w.l("");

    // NEX builtins: join/cancel operate on subtree semantics now
    w.l("fn __nex_join(task: __NexTask) { __nex_join_subtree(task.id); }");
    w.l("fn __nex_cancel(task: &__NexTask) { __nex_cancel_subtree(task.id); }");
    w.l("");

    // ------------------------------
    // Builtins
    // ------------------------------
    w.l("fn __nex_print(s: &str) { println!(\"{}\", s); }");
    w.l("");

    w.l("fn __nex_sleep_ms(ms: i64) {");
    w.ind += 1;
    w.l("std::thread::sleep(Duration::from_millis(ms.max(0) as u64));");
    w.ind = w.ind.saturating_sub(1);
    w.l("}");
    w.l("");

    w.l("fn __nex_read_file(path: &str) -> String {");
    w.ind += 1;
    w.l("if !__nex_fs_read_allowed(path) { panic!(\"NEX runtime: fs.read not allowed: {}\", path); }");
    w.l("let p = Path::new(\"sandbox_data\").join(path);");
    w.l("fs::read_to_string(p).unwrap_or_else(|_| \"\".to_string())");
    w.ind = w.ind.saturating_sub(1);
    w.l("}");
    w.l("");

    w.l("fn __nex_listen_http(port: i64) {");
    w.ind += 1;
    w.l("if !__nex_net_listen_allowed(port) { panic!(\"NEX runtime: net.listen not allowed: {}\", port); }");
    w.l("println!(\"(V1 stub) listening on port {}\", port);");
    w.ind = w.ind.saturating_sub(1);
    w.l("}");
    w.l("");

    // ------------------------------
    // User functions
    // ------------------------------
    for it in &program.items {
        if let Item::Function(f) = it {
            emit_function(&mut w, f);
            w.l("");
        }
    }

    // ------------------------------
    // Rust entrypoint wrapper (root scope guard)
    // ------------------------------
    w.l("fn main() {");
    w.ind += 1;
    w.l("__nex_install_root_task_context();");
    w.l("let _root_scope = __NexTaskScopeGuard::new(__nex_get_current_task_id());");
    w.l("let _ = __nex_user_main();");
    w.ind = w.ind.saturating_sub(1);
    w.l("}");

    w.out
}

fn collect_cap_allowlists(program: &Program) -> (Vec<String>, Vec<i64>) {
    let mut fs_globs = Vec::new();
    let mut net_ports = Vec::new();

    for it in &program.items {
        if let Item::Capability(c) = it {
            match &c.cap {
                Capability::FsRead { glob } => fs_globs.push(glob.clone()),
                Capability::NetListen { port } => net_ports.push(*port),
            }
        }
    }

    fs_globs.sort();
    fs_globs.dedup();
    net_ports.sort();
    net_ports.dedup();
    (fs_globs, net_ports)
}

fn emit_function(w: &mut W, f: &Function) {
    let rust_name = if f.name == "main" { "__nex_user_main" } else { &f.name };

    w.l(&format!(
        "fn {}({}){} {{",
        rust_name,
        emit_params(&f.params),
        emit_ret(&f.return_type)
    ));
    w.ind += 1;

    for s in &f.body.stmts {
        emit_stmt(w, s);
    }

    w.ind = w.ind.saturating_sub(1);
    w.l("}");
}

fn emit_params(params: &[crate::ast::Param]) -> String {
    params
        .iter()
        .map(|p| format!("{}: {}", p.name, emit_type(&p.ty)))
        .collect::<Vec<_>>()
        .join(", ")
}

fn emit_ret(rt: &Option<Type>) -> String {
    match rt {
        None => "".to_string(),
        Some(t) => format!(" -> {}", emit_type(t)),
    }
}

fn emit_type(t: &Type) -> String {
    match t {
        Type::I32 => "i64".to_string(),
        Type::F32 => "f64".to_string(),
        Type::Bool => "bool".to_string(),
        Type::String => "String".to_string(),
        Type::Task => "__NexTask".to_string(),
        Type::Named(n) => n.clone(),
    }
}

fn emit_stmt(w: &mut W, s: &Stmt) {
    match s {
        Stmt::Let { name, value, .. } => w.l(&format!("let mut {} = {};", name, emit_expr(value))),
        Stmt::Expr(e) => w.l(&format!("{};", emit_expr(e))),
        Stmt::Return(e) => {
            match e {
                Some(ex) => w.l(&format!("return {};", emit_expr(ex))),
                None => w.l("return;"),
            }
        },
        Stmt::If { cond, then_block, else_block } => {
            w.l(&format!("if {} {{", emit_expr(cond)));
            w.ind += 1;
            for st in &then_block.stmts {
                emit_stmt(w, st);
            }
            w.ind = w.ind.saturating_sub(1);
            if let Some(eb) = else_block {
                w.l("} else {");
                w.ind += 1;
                for st in &eb.stmts {
                    emit_stmt(w, st);
                }
                w.ind = w.ind.saturating_sub(1);
                w.l("}");
            } else {
                w.l("}");
            }
        }
        Stmt::Loop(b) => {
            w.l("loop {");
            w.ind += 1;
            for st in &b.stmts {
                emit_stmt(w, st);
            }
            w.ind = w.ind.saturating_sub(1);
            w.l("}");
        }
        Stmt::Defer(b) => {
            w.l("{ // defer (V1 inline)");
            w.ind += 1;
            for st in &b.stmts {
                emit_stmt(w, st);
            }
            w.ind = w.ind.saturating_sub(1);
            w.l("}");
        }
    }
}

fn emit_expr(e: &Expr) -> String {
    match e {
        Expr::Literal(Literal::Bool(b)) => b.to_string(),
        Expr::Literal(Literal::Int(i)) => i.to_string(),
        Expr::Literal(Literal::Float(f)) => f.to_string(),
        Expr::Literal(Literal::String(s)) => format!("String::from({:?})", s),
        Expr::Variable(v) => v.clone(),

        Expr::BinaryOp { left, op, right } => {
            let l = emit_expr(left);
            let r = emit_expr(right);
            let o = match op {
                BinOp::Add => "+",
                BinOp::Sub => "-",
                BinOp::Mul => "*",
                BinOp::Div => "/",
                BinOp::Eq => "==",
                BinOp::Ne => "!=",
                BinOp::Lt => "<",
                BinOp::Le => "<=",
                BinOp::Gt => ">",
                BinOp::Ge => ">=",
            };
            format!("({} {} {})", l, o, r)
        }

        Expr::If { cond, then_block, else_block } => {
            let mut s = String::new();
            s.push_str(&format!("if {} {{\n", emit_expr(cond)));
            for st in &then_block.stmts {
                s.push_str("    ");
                s.push_str(&stmt_inline(st));
                s.push('\n');
            }
            if let Some(eb) = else_block {
                s.push_str("} else {\n");
                for st in &eb.stmts {
                    s.push_str("    ");
                    s.push_str(&stmt_inline(st));
                    s.push('\n');
                }
                s.push_str("}");
            } else {
                s.push_str("}");
            }
            s
        }

        Expr::Block(b) => {
            let mut s = String::new();
            s.push_str("{\n");
            for st in &b.stmts {
                s.push_str("    ");
                s.push_str(&stmt_inline(st));
                s.push('\n');
            }
            s.push_str("}");
            s
        }

        // Structured spawn: always attaches to CURRENT_TASK_ID
        Expr::Spawn { block, .. } => {
            let mut inner = String::new();
            for st in &block.stmts {
                inner.push_str("    ");
                inner.push_str(&stmt_inline(st));
                inner.push('\n');
            }
            format!("__nex_spawn_child(|| {{\n{}}})", inner)
        }

        Expr::Call { func, args, .. } => {
            let a = args.iter().map(emit_expr).collect::<Vec<_>>();
            match func.as_str() {
                "print" => format!("__nex_print(&{})", a.get(0).cloned().unwrap_or_else(|| "String::new()".to_string())),
                "sleep_ms" => format!("__nex_sleep_ms({})", a.get(0).cloned().unwrap_or_else(|| "0".to_string())),
                "cancelled" => "__nex_cancelled()".to_string(),
                "join" => format!("__nex_join({})", a.get(0).cloned().unwrap_or_else(|| "__NexTask { id: 0 }".to_string())),
                "cancel" => format!("__nex_cancel(&{})", a.get(0).cloned().unwrap_or_else(|| "__NexTask { id: 0 }".to_string())),
                "read_file" | "fs.read" => format!("__nex_read_file(&{})", a.get(0).cloned().unwrap_or_else(|| "String::new()".to_string())),
                "listen_http" | "net.listen" => format!("__nex_listen_http({})", a.get(0).cloned().unwrap_or_else(|| "0".to_string())),
                _ => format!("{}({})", func, a.join(", ")),
            }
        }
    }
}

fn stmt_inline(s: &Stmt) -> String {
    match s {
        Stmt::Let { name, value, .. } => format!("let mut {} = {};", name, emit_expr(value)),
        Stmt::Expr(e) => format!("{};", emit_expr(e)),
        Stmt::Return(e) => match e {
            Some(ex) => format!("return {};", emit_expr(ex)),
            None => "return;".to_string(),
        },
        Stmt::If { .. } => "{ /* if-stmt */ }".to_string(),
        Stmt::Loop(_) => "{ /* loop */ }".to_string(),
        Stmt::Defer(_) => "{ /* defer */ }".to_string(),
    }
}

struct W {
    out: String,
    ind: usize,
}
impl W {
    fn new() -> Self {
        Self { out: String::new(), ind: 0 }
    }
    fn l(&mut self, s: &str) {
        for _ in 0..self.ind {
            self.out.push_str("    ");
        }
        self.out.push_str(s);
        self.out.push('\n');
    }
}
