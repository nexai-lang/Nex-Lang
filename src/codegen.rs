// src/codegen.rs
#![allow(dead_code, unused_mut)]

use crate::ast::{BinOp, Capability, Expr, Function, Item, Literal, Program, Stmt, Type};

pub fn generate_rust(program: &Program, _async_mode: bool) -> String {
    let mut w = W::new();

    w.l("// AUTO-GENERATED by NEX codegen. DO NOT EDIT.");
    w.l("// Step 51: Root cancellation token installed in main + per-task token in spawn.");
    w.l("");

    // ------------------------------
    // Imports
    // ------------------------------
    w.l("use std::cell::RefCell;");
    w.l("use std::fs;");
    w.l("use std::path::Path;");
    w.l("use std::sync::{Arc, OnceLock, atomic::{AtomicBool, Ordering}};");
    w.l("");

    // ------------------------------
    // Capability allowlists (defense-in-depth)
    // ------------------------------
    let (fs_globs, net_ports) = collect_cap_allowlists(program);

    w.l("static __NEX_FS_READ_ALLOW: &[&str] = &[");
    w.ind += 1;
    for g in fs_globs {
        w.l(&format!("{:?},", g));
    }
    w.ind -= 1;
    w.l("];");
    w.l("");

    w.l("static __NEX_NET_LISTEN_ALLOW: &[i64] = &[");
    w.ind += 1;
    for p in net_ports {
        w.l(&format!("{},", p));
    }
    w.ind -= 1;
    w.l("];");
    w.l("");

    w.l("fn __nex_fs_read_allowed(path: &str) -> bool {");
    w.ind += 1;
    w.l("__NEX_FS_READ_ALLOW.iter().any(|g| *g == \"*\" || *g == path)");
    w.ind -= 1;
    w.l("}");
    w.l("");

    w.l("fn __nex_net_listen_allowed(port: i64) -> bool {");
    w.ind += 1;
    w.l("__NEX_NET_LISTEN_ALLOW.iter().any(|p| *p == port)");
    w.ind -= 1;
    w.l("}");
    w.l("");

    // ------------------------------
    // Cancellation runtime (Step 51)
    // ------------------------------
    w.l("#[derive(Clone, Debug)]");
    w.l("struct __NexCancelToken { flag: Arc<AtomicBool> }");
    w.l("impl __NexCancelToken {");
    w.ind += 1;
    w.l("fn new() -> Self { Self { flag: Arc::new(AtomicBool::new(false)) } }");
    w.l("fn cancel(&self) { self.flag.store(true, Ordering::SeqCst); }");
    w.l("fn cancelled(&self) -> bool { self.flag.load(Ordering::SeqCst) }");
    w.ind -= 1;
    w.l("}");
    w.l("");

    w.l("static __NEX_ROOT_TOKEN: OnceLock<__NexCancelToken> = OnceLock::new();");
    w.l("thread_local! {");
    w.l("    static __NEX_CURRENT_TOKEN: RefCell<__NexCancelToken> = RefCell::new(__NexCancelToken::new());");
    w.l("}");
    w.l("");

    w.l("fn __nex_install_root_token() {");
    w.ind += 1;
    w.l("let root = __NEX_ROOT_TOKEN.get_or_init(__NexCancelToken::new).clone();");
    w.l("__NEX_CURRENT_TOKEN.with(|t| *t.borrow_mut() = root);");
    w.ind -= 1;
    w.l("}");
    w.l("");

    w.l("fn __nex_set_current_token(tok: __NexCancelToken) {");
    w.ind += 1;
    w.l("__NEX_CURRENT_TOKEN.with(|t| *t.borrow_mut() = tok);");
    w.ind -= 1;
    w.l("}");
    w.l("");

    w.l("fn __nex_cancelled() -> bool {");
    w.ind += 1;
    w.l("__NEX_CURRENT_TOKEN.with(|t| t.borrow().cancelled())");
    w.ind -= 1;
    w.l("}");
    w.l("");

    // ------------------------------
    // Task runtime
    // ------------------------------
    w.l("struct __NexTask {");
    w.ind += 1;
    w.l("handle: std::thread::JoinHandle<()>,");
    w.l("token: __NexCancelToken,");
    w.ind -= 1;
    w.l("}");
    w.l("");

    // âœ… Correct Rust syntax: where belongs in signature
    w.l("fn __nex_spawn<F>(f: F) -> __NexTask");
    w.l("where");
    w.l("    F: FnOnce() + Send + 'static,");
    w.l("{");
    w.ind += 1;
    w.l("let _root = __NEX_ROOT_TOKEN.get_or_init(__NexCancelToken::new).clone();");
    w.l("let task_token = __NexCancelToken::new();");
    w.l("let tok_for_thread = task_token.clone();");
    w.l("let handle = std::thread::spawn(move || {");
    w.ind += 1;
    w.l("__nex_set_current_token(tok_for_thread);");
    w.l("f();");
    w.ind -= 1;
    w.l("});");
    w.l("__NexTask { handle, token: task_token }");
    w.ind -= 1;
    w.l("}");
    w.l("");

    w.l("fn __nex_join(task: __NexTask) {");
    w.ind += 1;
    w.l("let _ = task.handle.join();");
    w.ind -= 1;
    w.l("}");
    w.l("");

    w.l("fn __nex_cancel(task: &__NexTask) {");
    w.ind += 1;
    w.l("task.token.cancel();");
    w.ind -= 1;
    w.l("}");
    w.l("");

    // ------------------------------
    // Builtins
    // ------------------------------
    w.l("fn __nex_print(s: &str) { println!(\"{}\", s); }");
    w.l("");

    w.l("fn __nex_read_file(path: &str) -> String {");
    w.ind += 1;
    w.l("if !__nex_fs_read_allowed(path) { panic!(\"NEX runtime: fs.read not allowed: {}\", path); }");
    w.l("let p = Path::new(\"sandbox_data\").join(path);");
    w.l("fs::read_to_string(p).unwrap_or_else(|_| \"\".to_string())");
    w.ind -= 1;
    w.l("}");
    w.l("");

    w.l("fn __nex_listen_http(port: i64) {");
    w.ind += 1;
    w.l("if !__nex_net_listen_allowed(port) { panic!(\"NEX runtime: net.listen not allowed: {}\", port); }");
    w.l("println!(\"(V1 stub) listening on port {}\", port);");
    w.ind -= 1;
    w.l("}");
    w.l("");

    // ------------------------------
    // User functions
    // ------------------------------
    for it in &program.items {
        if let Item::Function(f) = it {
            emit_function(&mut w, f);
            w.l("");
        }
    }

    // ------------------------------
    // Rust entrypoint wrapper
    // ------------------------------
    w.l("fn main() {");
    w.ind += 1;
    w.l("__nex_install_root_token();");
    w.l("let _ = __nex_user_main();");
    w.ind -= 1;
    w.l("}");

    w.out
}

fn collect_cap_allowlists(program: &Program) -> (Vec<String>, Vec<i64>) {
    let mut fs_globs = Vec::new();
    let mut net_ports = Vec::new();

    for it in &program.items {
        if let Item::Capability(c) = it {
            match &c.cap {
                Capability::FsRead { glob } => fs_globs.push(glob.clone()),
                Capability::NetListen { port } => net_ports.push(*port),
            }
        }
    }

    fs_globs.sort();
    fs_globs.dedup();
    net_ports.sort();
    net_ports.dedup();
    (fs_globs, net_ports)
}

fn emit_function(w: &mut W, f: &Function) {
    let rust_name = if f.name == "main" { "__nex_user_main" } else { &f.name };

    w.l(&format!(
        "fn {}({}){} {{",
        rust_name,
        emit_params(&f.params),
        emit_ret(&f.return_type)
    ));
    w.ind += 1;

    for s in &f.body.stmts {
        emit_stmt(w, s);
    }

    w.ind -= 1;
    w.l("}");
}

fn emit_params(params: &[crate::ast::Param]) -> String {
    params
        .iter()
        .map(|p| format!("{}: {}", p.name, emit_type(&p.ty)))
        .collect::<Vec<_>>()
        .join(", ")
}

fn emit_ret(rt: &Option<Type>) -> String {
    match rt {
        None => "".to_string(),
        Some(t) => format!(" -> {}", emit_type(t)),
    }
}

fn emit_type(t: &Type) -> String {
    match t {
        Type::I32 => "i64".to_string(),
        Type::F32 => "f64".to_string(),
        Type::Bool => "bool".to_string(),
        Type::String => "String".to_string(),
        Type::Task => "__NexTask".to_string(),
        Type::Named(n) => n.clone(),
    }
}

fn emit_stmt(w: &mut W, s: &Stmt) {
    match s {
        Stmt::Let { name, value, .. } => {
            w.l(&format!("let mut {} = {};", name, emit_expr(value)));
        }
        Stmt::Expr(e) => {
            w.l(&format!("{};", emit_expr(e)));
        }
        Stmt::Return(e) => {
            w.l(&format!("return {};", emit_expr(e)));
        }
        Stmt::If {
            cond,
            then_block,
            else_block,
        } => {
            w.l(&format!("if {} {{", emit_expr(cond)));
            w.ind += 1;
            for st in &then_block.stmts {
                emit_stmt(w, st);
            }
            w.ind -= 1;
            if let Some(eb) = else_block {
                w.l("} else {");
                w.ind += 1;
                for st in &eb.stmts {
                    emit_stmt(w, st);
                }
                w.ind -= 1;
                w.l("}");
            } else {
                w.l("}");
            }
        }
        Stmt::Loop(b) => {
            w.l("loop {");
            w.ind += 1;
            for st in &b.stmts {
                emit_stmt(w, st);
            }
            w.ind -= 1;
            w.l("}");
        }
        Stmt::Defer(b) => {
            // V1: inline (not true defer semantics yet)
            w.l("{ // defer (V1 inline)");
            w.ind += 1;
            for st in &b.stmts {
                emit_stmt(w, st);
            }
            w.ind -= 1;
            w.l("}");
        }
    }
}

fn emit_expr(e: &Expr) -> String {
    match e {
        Expr::Literal(Literal::Bool(b)) => b.to_string(),
        Expr::Literal(Literal::Int(i)) => i.to_string(),
        Expr::Literal(Literal::Float(f)) => f.to_string(),
        Expr::Literal(Literal::String(s)) => format!("String::from({:?})", s),
        Expr::Variable(v) => v.clone(),

        Expr::BinaryOp { left, op, right } => {
            let l = emit_expr(left);
            let r = emit_expr(right);
            let o = match op {
                BinOp::Add => "+",
                BinOp::Sub => "-",
                BinOp::Mul => "*",
                BinOp::Div => "/",
                BinOp::Eq => "==",
                BinOp::Ne => "!=",
                BinOp::Lt => "<",
                BinOp::Le => "<=",
                BinOp::Gt => ">",
                BinOp::Ge => ">=",
            };
            format!("({} {} {})", l, o, r)
        }

        Expr::If { cond, then_block, else_block } => {
            let mut s = String::new();
            s.push_str(&format!("if {} {{\n", emit_expr(cond)));
            for st in &then_block.stmts {
                s.push_str("    ");
                s.push_str(&stmt_inline(st));
                s.push('\n');
            }
            if let Some(eb) = else_block {
                s.push_str("} else {\n");
                for st in &eb.stmts {
                    s.push_str("    ");
                    s.push_str(&stmt_inline(st));
                    s.push('\n');
                }
                s.push_str("}");
            } else {
                s.push_str("}");
            }
            s
        }

        Expr::Block(b) => {
            let mut s = String::new();
            s.push_str("{\n");
            for st in &b.stmts {
                s.push_str("    ");
                s.push_str(&stmt_inline(st));
                s.push('\n');
            }
            s.push_str("}");
            s
        }

        Expr::Spawn { block, .. } => {
            let mut inner = String::new();
            for st in &block.stmts {
                inner.push_str("    ");
                inner.push_str(&stmt_inline(st));
                inner.push('\n');
            }
            format!("__nex_spawn(|| {{\n{}}})", inner)
        }

        Expr::Call { func, args, .. } => {
            // builtins + dotted calls
            let a = args.iter().map(emit_expr).collect::<Vec<_>>();

            match func.as_str() {
                "print" => format!("__nex_print(&{})", a.get(0).cloned().unwrap_or_else(|| "String::new()".to_string())),
                "cancelled" => "__nex_cancelled()".to_string(),
                "join" => format!("__nex_join({})", a.get(0).cloned().unwrap_or_else(|| "__nex_spawn(|| {})".to_string())),
                "cancel" => format!("__nex_cancel(&{})", a.get(0).cloned().unwrap_or_else(|| "__nex_spawn(|| {})".to_string())),

                "read_file" | "fs.read" => {
                    let p = a.get(0).cloned().unwrap_or_else(|| "String::new()".to_string());
                    format!("__nex_read_file(&{})", p)
                }
                "listen_http" | "net.listen" => {
                    let p = a.get(0).cloned().unwrap_or_else(|| "0".to_string());
                    format!("__nex_listen_http({})", p)
                }
                _ => format!("{}({})", func, a.join(", ")),
            }
        }
    }
}

fn stmt_inline(s: &Stmt) -> String {
    match s {
        Stmt::Let { name, value, .. } => format!("let mut {} = {};", name, emit_expr(value)),
        Stmt::Expr(e) => format!("{};", emit_expr(e)),
        Stmt::Return(e) => format!("return {};", emit_expr(e)),
        Stmt::If { .. } => "{ /* if-stmt */ }".to_string(),
        Stmt::Loop(_) => "{ /* loop */ }".to_string(),
        Stmt::Defer(_) => "{ /* defer */ }".to_string(),
    }
}

struct W {
    out: String,
    ind: usize,
}
impl W {
    fn new() -> Self {
        Self { out: String::new(), ind: 0 }
    }
    fn l(&mut self, s: &str) {
        for _ in 0..self.ind {
            self.out.push_str("    ");
        }
        self.out.push_str(s);
        self.out.push('\n');
    }
}
