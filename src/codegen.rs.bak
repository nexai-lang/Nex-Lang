// src/codegen.rs
//
// v0.5.6 â€” Deterministic Observability + Minimal AST-driven runner
//
// This codegen is intentionally scoped to unblock v0.5.x golden + tamper workflows
// while restoring SEMANTIC spawn emission deterministically using the real AST.
//
// It supports the minimal subset needed by tests like:
//   fn main() !async {
//     let t = spawn { };
//     join(t);
//   }
//
// Invariants honored:
// - Workspace isolation via NEX_OUT_DIR
// - Canonical binary log is source-of-truth
// - Hash stream excludes RunFinished
// - Deterministic JSONL formatting (no HashMap/serde)
// - Little-endian encoding everywhere (.to_le_bytes())

#![allow(dead_code, unused_variables)]

use crate::ast::{Block, Expr, Item, Program, Stmt};

pub fn generate_rust(
    program: &Program,
    _async_mode: bool,
    codegen_hash: [u8; 32],
    source_hash: [u8; 32],
) -> String {
    // Find main() body (required for runner)
    let main_body = find_main_block(program);

    let mut w = W::new();
    w.l("// AUTO-GENERATED by NEX codegen. DO NOT EDIT.");
    w.l("#![allow(dead_code, unused_mut, unused_variables)]");
    w.l("");

    // Imports (keep deterministic + minimal)
    w.l("use std::fs;");
    w.l("use std::io::{Write, BufWriter};");
    w.l("use std::sync::{OnceLock, Mutex, atomic::{AtomicU64, Ordering}};");
    w.l("use sha2::{Digest, Sha256};");
    w.l("");

    // ---------- Output dir (Invariant I6) ----------
    w.l("fn __nex_out_dir() -> String {");
    w.ind += 1;
    w.l("match std::env::var(\"NEX_OUT_DIR\") {");
    w.ind += 1;
    w.l("Ok(v) if !v.trim().is_empty() => v,");
    w.l("_ => \"./nex_out\".to_string(),");
    w.ind -= 1;
    w.l("}");
    w.ind -= 1;
    w.l("}");
    w.l("");

    // ---------- Log header hardening ----------
    w.l("const __NEX_LOG_MAGIC: [u8; 4] = *b\"NEXL\";");
    w.l("const __NEX_LOG_VERSION: u16 = 1;");
    w.l("const __NEX_LOG_FLAGS: u16 = 0;");
    w.l("");

    // Embed hashes deterministically
    w.l("const __NEX_CODEGEN_HASH: [u8; 32] = [");
    w.ind += 1;
    for b in codegen_hash {
        w.l(&format!("{},", b));
    }
    w.ind -= 1;
    w.l("];");
    w.l("const __NEX_SOURCE_HASH: [u8; 32] = [");
    w.ind += 1;
    for b in source_hash {
        w.l(&format!("{},", b));
    }
    w.ind -= 1;
    w.l("];");
    w.l("");

    // ---------- Global writers + hasher ----------
    w.l("static __BIN: OnceLock<Mutex<BufWriter<std::fs::File>>> = OnceLock::new();");
    w.l("static __JSONL: OnceLock<Mutex<BufWriter<std::fs::File>>> = OnceLock::new();");
    w.l("static __HASH: OnceLock<Mutex<Sha256>> = OnceLock::new();");
    w.l("static __SEQ: AtomicU64 = AtomicU64::new(0);");
    w.l("static __NEXT_TASK_ID: AtomicU64 = AtomicU64::new(1);");
    w.l("static __HDR_WRITTEN: OnceLock<()> = OnceLock::new();");
    w.l("");

    w.l("fn __bin_path() -> std::path::PathBuf {");
    w.ind += 1;
    w.l("let out_dir = __nex_out_dir();");
    w.l("fs::create_dir_all(&out_dir).expect(\"failed to create NEX_OUT_DIR\");");
    w.l("std::path::Path::new(&out_dir).join(\"run.events.bin\")");
    w.ind -= 1;
    w.l("}");
    w.l("");

    w.l("fn __jsonl_path() -> std::path::PathBuf {");
    w.ind += 1;
    w.l("let out_dir = __nex_out_dir();");
    w.l("fs::create_dir_all(&out_dir).expect(\"failed to create NEX_OUT_DIR\");");
    w.l("std::path::Path::new(&out_dir).join(\"run.events.jsonl\")");
    w.ind -= 1;
    w.l("}");
    w.l("");

    w.l("fn __bin() -> &'static Mutex<BufWriter<std::fs::File>> {");
    w.ind += 1;
    w.l("__BIN.get_or_init(|| {");
    w.ind += 1;
    w.l("let f = std::fs::OpenOptions::new()");
    w.ind += 1;
    w.l(".create(true)");
    w.l(".write(true)");
    w.l(".truncate(true)");
    w.l(".open(__bin_path())");
    w.l(".expect(\"open run.events.bin\");");
    w.ind -= 1;
    w.l("Mutex::new(BufWriter::new(f))");
    w.ind -= 1;
    w.l("})");
    w.ind -= 1;
    w.l("}");
    w.l("");

    w.l("fn __jsonl() -> &'static Mutex<BufWriter<std::fs::File>> {");
    w.ind += 1;
    w.l("__JSONL.get_or_init(|| {");
    w.ind += 1;
    w.l("let f = std::fs::OpenOptions::new()");
    w.ind += 1;
    w.l(".create(true)");
    w.l(".write(true)");
    w.l(".truncate(true)");
    w.l(".open(__jsonl_path())");
    w.l(".expect(\"open run.events.jsonl\");");
    w.ind -= 1;
    w.l("Mutex::new(BufWriter::new(f))");
    w.ind -= 1;
    w.l("})");
    w.ind -= 1;
    w.l("}");
    w.l("");

    w.l("fn __hasher() -> &'static Mutex<Sha256> {");
    w.ind += 1;
    w.l("__HASH.get_or_init(|| Mutex::new(Sha256::new()))");
    w.ind -= 1;
    w.l("}");
    w.l("");

    // ---------- CRC32 (deterministic, internal) ----------
    w.l("fn __crc32(bytes: &[u8]) -> u32 {");
    w.ind += 1;
    w.l("let mut crc: u32 = 0xFFFF_FFFF;");
    w.l("for &b in bytes {");
    w.ind += 1;
    w.l("crc ^= b as u32;");
    w.l("for _ in 0..8 {");
    w.ind += 1;
    w.l("let mask = (crc & 1).wrapping_neg();");
    w.l("crc = (crc >> 1) ^ (0xEDB8_8320 & mask);");
    w.ind -= 1;
    w.l("}");
    w.ind -= 1;
    w.l("}");
    w.l("!crc");
    w.ind -= 1;
    w.l("}");
    w.l("");

    // ---------- Deterministic hex ----------
    w.l("fn __hex(bytes: &[u8]) -> String {");
    w.ind += 1;
    w.l("const LUT: &[u8; 16] = b\"0123456789abcdef\";");
    w.l("let mut s = String::with_capacity(bytes.len() * 2);");
    w.l("for &b in bytes {");
    w.ind += 1;
    w.l("s.push(LUT[(b >> 4) as usize] as char);");
    w.l("s.push(LUT[(b & 0x0F) as usize] as char);");
    w.ind -= 1;
    w.l("}");
    w.l("s");
    w.ind -= 1;
    w.l("}");
    w.l("");

    // ---------- Header (write-once, hashed) ----------
    w.l("fn __write_header_once() {");
    w.ind += 1;
    w.l("__HDR_WRITTEN.get_or_init(|| {");
    w.ind += 1;
    w.l("let mut hdr: Vec<u8> = Vec::with_capacity(4 + 2 + 32 + 32 + 2 + 4);");
    w.l("hdr.extend_from_slice(&__NEX_LOG_MAGIC);");
    w.l("hdr.extend_from_slice(&__NEX_LOG_VERSION.to_le_bytes());");
    w.l("hdr.extend_from_slice(&__NEX_CODEGEN_HASH);");
    w.l("hdr.extend_from_slice(&__NEX_SOURCE_HASH);");
    w.l("hdr.extend_from_slice(&__NEX_LOG_FLAGS.to_le_bytes());");
    w.l("hdr.extend_from_slice(&0u32.to_le_bytes()); // CRC placeholder");
    w.l("let crc = __crc32(&hdr[..hdr.len() - 4]);");
    w.l("let n = hdr.len();");
    w.l("hdr[n - 4..n].copy_from_slice(&crc.to_le_bytes());");

    w.l("{");
    w.ind += 1;
    w.l("let mut b = __bin().lock().expect(\"bin lock\");");
    w.l("b.write_all(&hdr).expect(\"write header\");");
    w.l("b.flush().expect(\"flush header\");");
    w.ind -= 1;
    w.l("}");

    w.l("{");
    w.ind += 1;
    w.l("let mut h = __hasher().lock().expect(\"hash lock\");");
    w.l("h.update(&hdr);");
    w.ind -= 1;
    w.l("}");

    w.ind -= 1;
    w.l("});");
    w.ind -= 1;
    w.l("}");
    w.l("");

    // ---------- Event kinds ----------
    w.l("const __KIND_TASK_SPAWNED: u16 = 1;");
    w.l("const __KIND_RUN_STARTED: u16 = 0xFFFE;");
    w.l("const __KIND_RUN_FINISHED: u16 = 0xFFFF;");
    w.l("");

    // ---------- Canonical event record ----------
    // Frame: [seq:u64][task:u64][kind:u16][len:u32][payload:bytes]
    w.l("fn __record_event(task: u64, kind: u16, payload: &[u8], include_in_hash: bool) {");
    w.ind += 1;
    w.l("__write_header_once();");
    w.l("let seq = __SEQ.fetch_add(1, Ordering::Relaxed);");
    w.l("let len = payload.len() as u32;");
    w.l("let mut frame: Vec<u8> = Vec::with_capacity(8 + 8 + 2 + 4 + payload.len());");
    w.l("frame.extend_from_slice(&seq.to_le_bytes());");
    w.l("frame.extend_from_slice(&task.to_le_bytes());");
    w.l("frame.extend_from_slice(&kind.to_le_bytes());");
    w.l("frame.extend_from_slice(&len.to_le_bytes());");
    w.l("frame.extend_from_slice(payload);");

    // Canonical supremacy: write binary first
    w.l("{");
    w.ind += 1;
    w.l("let mut b = __bin().lock().expect(\"bin lock\");");
    w.l("b.write_all(&frame).expect(\"write event\");");
    w.l("b.flush().expect(\"flush event\");");
    w.ind -= 1;
    w.l("}");

    // Hash after successful binary write
    w.l("if include_in_hash {");
    w.ind += 1;
    w.l("let mut h = __hasher().lock().expect(\"hash lock\");");
    w.l("h.update(&frame);");
    w.ind -= 1;
    w.l("}");

    // Deterministic JSONL (fail-fast)
    w.l("{");
    w.ind += 1;
    w.l("let payload_hex = __hex(payload);");
    w.l("let line = format!(\"{{\\\"seq\\\":{},\\\"task\\\":{},\\\"kind\\\":{},\\\"payload_hex\\\":\\\"{}\\\"}}\", seq, task, kind, payload_hex);");
    w.l("let mut j = __jsonl().lock().expect(\"jsonl lock\");");
    w.l("j.write_all(line.as_bytes()).expect(\"write jsonl\");");
    w.l("j.write_all(b\"\\n\").expect(\"write jsonl nl\");");
    w.l("j.flush().expect(\"flush jsonl\");");
    w.ind -= 1;
    w.l("}");

    w.ind -= 1;
    w.l("}");
    w.l("");

    // ---------- Minimal structured spawn primitive (deterministic IDs) ----------
    w.l("fn __spawn_task(parent: u64, f: impl FnOnce()) -> u64 {");
    w.ind += 1;
    w.l("let child = __NEXT_TASK_ID.fetch_add(1, Ordering::Relaxed);");
    w.l("let mut payload: Vec<u8> = Vec::with_capacity(16);");
    w.l("payload.extend_from_slice(&parent.to_le_bytes());");
    w.l("payload.extend_from_slice(&child.to_le_bytes());");
    w.l("__record_event(parent, __KIND_TASK_SPAWNED, &payload, true);");
    w.l("// Minimal runner: execute immediately (deterministic).");
    w.l("f();");
    w.l("child");
    w.ind -= 1;
    w.l("}");
    w.l("");

    w.l("fn __join(_task_id: u64) {");
    w.ind += 1;
    w.l("// Minimal runner: task already executed synchronously.");
    w.ind -= 1;
    w.l("}");
    w.l("");

    // ---------- RunFinished (excluded from hash) ----------
    w.l("fn __finish(exit_code: u32) {");
    w.ind += 1;
    w.l("__write_header_once();");
    w.l("let run_hash = {");
    w.ind += 1;
    w.l("let h = __hasher().lock().expect(\"hash lock\");");
    w.l("let d = h.clone().finalize();");
    w.l("let mut out = [0u8; 32];");
    w.l("out.copy_from_slice(&d[..]);");
    w.l("out");
    w.ind -= 1;
    w.l("};");
    w.l("let mut payload: Vec<u8> = Vec::with_capacity(4 + 32);");
    w.l("payload.extend_from_slice(&exit_code.to_le_bytes());");
    w.l("payload.extend_from_slice(&run_hash);");
    w.l("__record_event(0, __KIND_RUN_FINISHED, &payload, false);");
    w.ind -= 1;
    w.l("}");
    w.l("");

    // ---------- Program entry ----------
    w.l("fn main() {");
    w.ind += 1;
    w.l("__record_event(0, __KIND_RUN_STARTED, &[], true);");
    w.l("let __cur_task: u64 = 0;");

    // Generate body of fn main from AST
    emit_block(&mut w, &main_body, "__cur_task");

    w.l("println!(\"OK\");");
    w.l("__finish(0);");
    w.ind -= 1;
    w.l("}");
    w.l("");

    w.out
}

// ---- AST helpers (codegen-time) ----

fn find_main_block(program: &Program) -> Block {
    for it in &program.items {
        if let Item::Function(f) = it {
            if f.name == "main" {
                return f.body.clone();
            }
        }
    }
    // Fail-fast at compile-time: generated program would be meaningless otherwise
    Block { stmts: vec![] }
}

fn emit_block(w: &mut W, b: &Block, cur_task_var: &str) {
    for s in &b.stmts {
        emit_stmt(w, s, cur_task_var);
    }
}

fn emit_stmt(w: &mut W, s: &Stmt, cur_task_var: &str) {
    match s {
        Stmt::Let { name, ty: _, value } => {
            // Only needs to support `let t = spawn { ... };`
            w.l(&format!("let {} = {};", sanitize_ident(name), emit_expr(value, cur_task_var)));
        }
        Stmt::Expr(e) => {
            w.l(&format!("{};", emit_expr(e, cur_task_var)));
        }
        Stmt::Return(opt) => {
            if let Some(e) = opt {
                w.l(&format!("let _ = {};", emit_expr(e, cur_task_var)));
            }
            w.l("return;");
        }
        Stmt::If { cond, then_block, else_block } => {
            w.l(&format!("if {} {{", emit_expr(cond, cur_task_var)));
            w.ind += 1;
            emit_block(w, then_block, cur_task_var);
            w.ind -= 1;
            if let Some(eb) = else_block {
                w.l("} else {");
                w.ind += 1;
                emit_block(w, eb, cur_task_var);
                w.ind -= 1;
                w.l("}");
            } else {
                w.l("}");
            }
        }
        Stmt::Loop(body) => {
            // Minimal deterministic loop support (no fuel here; this is codegen shim)
            w.l("loop {");
            w.ind += 1;
            emit_block(w, body, cur_task_var);
            w.ind -= 1;
            w.l("}");
        }
        Stmt::Defer(body) => {
            // Minimal: execute immediately (deterministic), real defer semantics can be added later.
            emit_block(w, body, cur_task_var);
        }
    }
}

fn emit_expr(e: &Expr, cur_task_var: &str) -> String {
    match e {
        Expr::Spawn { block, span: _ } => {
            // __spawn_task(__cur_task, || { ... })
            // We must generate a closure body.
            let mut inner = String::new();
            inner.push_str("{\n");
            for s in &block.stmts {
                // Keep inner indentation basic; this is generated Rust.
                inner.push_str("        ");
                inner.push_str(&emit_stmt_as_inline(s, cur_task_var));
                inner.push('\n');
            }
            inner.push_str("    }");
            format!("__spawn_task({}, || {})", cur_task_var, inner)
        }
        Expr::Call { func, args, span: _ } => {
            // Built-in join(t)
            if func == "join" && args.len() == 1 {
                format!("__join({})", emit_expr(&args[0], cur_task_var))
            } else {
                // For now, unknown calls become no-ops returning unit.
                // (We are keeping scope tight for v0.5.x golden/tamper.)
                "(() )".to_string()
            }
        }
        Expr::Variable(name) => sanitize_ident(name),
        Expr::Block(b) => {
            let mut s = String::new();
            s.push_str("{ ");
            for st in &b.stmts {
                s.push_str(&emit_stmt_as_inline(st, cur_task_var));
                s.push(' ');
            }
            s.push_str(" }");
            s
        }
        Expr::If { cond, then_block, else_block } => {
            let then_s = block_to_inline(then_block, cur_task_var);
            let else_s = else_block
                .as_ref()
                .map(|b| block_to_inline(b, cur_task_var))
                .unwrap_or_else(|| "{ () }".to_string());
            format!("if {} {} else {}", emit_expr(cond, cur_task_var), then_s, else_s)
        }
        Expr::BinaryOp { left, op: _, right } => {
            // Minimal: evaluate subexpressions but discard (tight scope).
            format!("{{ let _ = {}; let _ = {}; () }}", emit_expr(left, cur_task_var), emit_expr(right, cur_task_var))
        }
        Expr::Literal(_) => "(() )".to_string(),
    }
}

fn emit_stmt_as_inline(s: &Stmt, cur_task_var: &str) -> String {
    match s {
        Stmt::Let { name, ty: _, value } => format!(
            "let {} = {};",
            sanitize_ident(name),
            emit_expr(value, cur_task_var)
        ),
        Stmt::Expr(e) => format!("{};", emit_expr(e, cur_task_var)),
        Stmt::Return(opt) => {
            if let Some(e) = opt {
                format!("let _ = {}; return;", emit_expr(e, cur_task_var))
            } else {
                "return;".to_string()
            }
        }
        Stmt::If { cond, then_block, else_block } => {
            let then_s = block_to_inline(then_block, cur_task_var);
            let else_s = else_block
                .as_ref()
                .map(|b| format!(" else {}", block_to_inline(b, cur_task_var)))
                .unwrap_or_default();
            format!("if {} {}{}", emit_expr(cond, cur_task_var), then_s, else_s)
        }
        Stmt::Loop(body) => format!("loop {}",
            block_to_inline(body, cur_task_var)
        ),
        Stmt::Defer(body) => {
            // Minimal: run now
            block_to_inline(body, cur_task_var)
        }
    }
}

fn block_to_inline(b: &Block, cur_task_var: &str) -> String {
    let mut s = String::new();
    s.push_str("{ ");
    for st in &b.stmts {
        s.push_str(&emit_stmt_as_inline(st, cur_task_var));
        s.push(' ');
    }
    s.push_str("}");
    s
}

fn sanitize_ident(name: &str) -> String {
    // Very small sanitization (tight scope). Real hygiene can come later.
    // Replace '-' with '_' etc.
    name.chars()
        .map(|c| if c.is_ascii_alphanumeric() || c == '_' { c } else { '_' })
        .collect()
}

// ---- Tiny writer ----
struct W {
    out: String,
    ind: usize,
}

impl W {
    fn new() -> Self {
        Self {
            out: String::new(),
            ind: 0,
        }
    }

    fn l(&mut self, s: &str) {
        for _ in 0..self.ind {
            self.out.push_str("    ");
        }
        self.out.push_str(s);
        self.out.push('\n');
    }
}
