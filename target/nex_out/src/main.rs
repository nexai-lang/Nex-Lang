// AUTO-GENERATED by NEX codegen. DO NOT EDIT.
// Step 51: Root cancellation token installed in main + per-task token in spawn.

use std::cell::RefCell;
use std::fs;
use std::path::Path;
use std::sync::{Arc, OnceLock, atomic::{AtomicBool, Ordering}};

static __NEX_FS_READ_ALLOW: &[&str] = &[
];

static __NEX_NET_LISTEN_ALLOW: &[i64] = &[
];

fn __nex_fs_read_allowed(path: &str) -> bool {
    __NEX_FS_READ_ALLOW.iter().any(|g| *g == "*" || *g == path)
}

fn __nex_net_listen_allowed(port: i64) -> bool {
    __NEX_NET_LISTEN_ALLOW.iter().any(|p| *p == port)
}

#[derive(Clone, Debug)]
struct __NexCancelToken { flag: Arc<AtomicBool> }
impl __NexCancelToken {
    fn new() -> Self { Self { flag: Arc::new(AtomicBool::new(false)) } }
    fn cancel(&self) { self.flag.store(true, Ordering::SeqCst); }
    fn cancelled(&self) -> bool { self.flag.load(Ordering::SeqCst) }
}

static __NEX_ROOT_TOKEN: OnceLock<__NexCancelToken> = OnceLock::new();
thread_local! {
    static __NEX_CURRENT_TOKEN: RefCell<__NexCancelToken> = RefCell::new(__NexCancelToken::new());
}

fn __nex_install_root_token() {
    let root = __NEX_ROOT_TOKEN.get_or_init(__NexCancelToken::new).clone();
    __NEX_CURRENT_TOKEN.with(|t| *t.borrow_mut() = root);
}

fn __nex_set_current_token(tok: __NexCancelToken) {
    __NEX_CURRENT_TOKEN.with(|t| *t.borrow_mut() = tok);
}

fn __nex_cancelled() -> bool {
    __NEX_CURRENT_TOKEN.with(|t| t.borrow().cancelled())
}

struct __NexTask {
    handle: std::thread::JoinHandle<()>,
    token: __NexCancelToken,
}

fn __nex_spawn<F>(f: F) -> __NexTask
where
    F: FnOnce() + Send + 'static,
{
    let _root = __NEX_ROOT_TOKEN.get_or_init(__NexCancelToken::new).clone();
    let task_token = __NexCancelToken::new();
    let tok_for_thread = task_token.clone();
    let handle = std::thread::spawn(move || {
        __nex_set_current_token(tok_for_thread);
        f();
    });
    __NexTask { handle, token: task_token }
}

fn __nex_join(task: __NexTask) {
    let _ = task.handle.join();
}

fn __nex_cancel(task: &__NexTask) {
    task.token.cancel();
}

fn __nex_print(s: &str) { println!("{}", s); }

fn __nex_read_file(path: &str) -> String {
    if !__nex_fs_read_allowed(path) { panic!("NEX runtime: fs.read not allowed: {}", path); }
    let p = Path::new("sandbox_data").join(path);
    fs::read_to_string(p).unwrap_or_else(|_| "".to_string())
}

fn __nex_listen_http(port: i64) {
    if !__nex_net_listen_allowed(port) { panic!("NEX runtime: net.listen not allowed: {}", port); }
    println!("(V1 stub) listening on port {}", port);
}

fn __nex_user_main() {
    if __nex_cancelled() {
        __nex_print(&String::from("CANCELLED"));
    } else {
        __nex_print(&String::from("NOT CANCELLED"));
    }
}

fn main() {
    __nex_install_root_token();
    let _ = __nex_user_main();
}
