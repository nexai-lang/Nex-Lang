#![allow(dead_code, unused_mut)]
// AUTO-GENERATED by NEX codegen. DO NOT EDIT.
// v0.2.0: Structured Concurrency (Task Trees)
// - Step 0.2.1: Task Context + Registry
// - Step 0.2.3: Cancellation Propagation (subtree cancel)
// - Step 0.2.4: Deterministic Cleanup (auto-cancel + join children on exit)

use std::cell::RefCell;
use std::collections::{HashMap, VecDeque};
use std::fs;
use std::path::Path;
use std::sync::{Arc, OnceLock, Mutex, atomic::{AtomicBool, AtomicU64, Ordering}};
use std::time::Duration;

static __NEX_FS_READ_ALLOW: &[&str] = &[
];

static __NEX_NET_LISTEN_ALLOW: &[i64] = &[
];

fn __nex_fs_read_allowed(path: &str) -> bool {
    __NEX_FS_READ_ALLOW.iter().any(|g| *g == "*" || *g == path)
}

fn __nex_net_listen_allowed(port: i64) -> bool {
    __NEX_NET_LISTEN_ALLOW.iter().any(|p| *p == port)
}

#[allow(dead_code)]
#[derive(Clone, Debug)]
struct __NexCancelToken { flag: Arc<AtomicBool> }
impl __NexCancelToken {
    fn new() -> Self { Self { flag: Arc::new(AtomicBool::new(false)) } }
    fn cancel(&self) { self.flag.store(true, Ordering::SeqCst); }
    fn cancelled(&self) -> bool { self.flag.load(Ordering::SeqCst) }
}

static __NEX_ROOT_TOKEN: OnceLock<__NexCancelToken> = OnceLock::new();
thread_local! {
    static __NEX_CURRENT_TOKEN: RefCell<__NexCancelToken> = RefCell::new(__NexCancelToken::new());
}

fn __nex_install_root_token() {
    let root = __NEX_ROOT_TOKEN.get_or_init(__NexCancelToken::new).clone();
    __NEX_CURRENT_TOKEN.with(|t| *t.borrow_mut() = root);
}

fn __nex_set_current_token(tok: __NexCancelToken) {
    __NEX_CURRENT_TOKEN.with(|t| *t.borrow_mut() = tok);
}

fn __nex_cancelled() -> bool {
    __NEX_CURRENT_TOKEN.with(|t| t.borrow().cancelled())
}

type __NexTaskId = u64;
static __NEX_TASK_ID_GEN: AtomicU64 = AtomicU64::new(1);

#[allow(dead_code)]
struct __NexTaskMeta {
    parent: Option<__NexTaskId>,
    children: Vec<__NexTaskId>,
    token: __NexCancelToken,
    handle: Option<std::thread::JoinHandle<()>>,
}

static __NEX_TASK_REGISTRY: OnceLock<Mutex<HashMap<__NexTaskId, __NexTaskMeta>>> = OnceLock::new();

fn __nex_registry() -> &'static Mutex<HashMap<__NexTaskId, __NexTaskMeta>> {
    __NEX_TASK_REGISTRY.get_or_init(|| Mutex::new(HashMap::new()))
}

thread_local! {
    static __NEX_CURRENT_TASK_ID: RefCell<__NexTaskId> = RefCell::new(0);
}

fn __nex_get_current_task_id() -> __NexTaskId {
    __NEX_CURRENT_TASK_ID.with(|id| *id.borrow())
}

fn __nex_set_current_task_id(id: __NexTaskId) {
    __NEX_CURRENT_TASK_ID.with(|cur| *cur.borrow_mut() = id);
}

#[derive(Clone, Copy, Debug)]
struct __NexTask { id: __NexTaskId }

struct __NexTaskScopeGuard { task_id: __NexTaskId }
impl __NexTaskScopeGuard {
    fn new(task_id: __NexTaskId) -> Self { Self { task_id } }
}
impl Drop for __NexTaskScopeGuard {
    fn drop(&mut self) {
        // On task exit: cancel + join all remaining children (subtree), deterministically.
        __nex_cancel_children_subtree(self.task_id);
        __nex_join_children_subtree(self.task_id);
    }
}

fn __nex_install_root_task_context() {
    __nex_install_root_token();
    let root_id: __NexTaskId = 0;
    __nex_set_current_task_id(root_id);
    let root_tok = __NEX_CURRENT_TOKEN.with(|t| t.borrow().clone());
    let mut reg = __nex_registry().lock().expect("NEX runtime: TASK_REGISTRY mutex poisoned");
    reg.entry(root_id).or_insert(__NexTaskMeta { parent: None, children: Vec::new(), token: root_tok, handle: None });
}

fn __nex_collect_subtree_postorder(root: __NexTaskId) -> Vec<__NexTaskId> {
    let reg = __nex_registry().lock().expect("NEX runtime: TASK_REGISTRY mutex poisoned");
    let mut out: Vec<__NexTaskId> = Vec::new();
    fn dfs(id: __NexTaskId, reg: &HashMap<__NexTaskId, __NexTaskMeta>, out: &mut Vec<__NexTaskId>) {
        if let Some(m) = reg.get(&id) {
            for &c in &m.children { dfs(c, reg, out); }
            out.push(id);
        } else {
            // If missing, still include the id to keep behavior stable.
            out.push(id);
        }
    }
dfs(root, &reg, &mut out);
out
}

fn __nex_collect_children_subtree_postorder(parent: __NexTaskId) -> Vec<__NexTaskId> {
    let reg = __nex_registry().lock().expect("NEX runtime: TASK_REGISTRY mutex poisoned");
    let mut out: Vec<__NexTaskId> = Vec::new();
    if let Some(m) = reg.get(&parent) {
        fn dfs(id: __NexTaskId, reg: &HashMap<__NexTaskId, __NexTaskMeta>, out: &mut Vec<__NexTaskId>) {
            if let Some(m) = reg.get(&id) {
                for &c in &m.children { dfs(c, reg, out); }
                out.push(id);
            } else { out.push(id); }
        }
    for &c in &m.children { dfs(c, &reg, &mut out); }
}
out
}

fn __nex_cancel_subtree(root: __NexTaskId) {
    let ids = __nex_collect_subtree_postorder(root);
    // Cancel tokens (no need to hold the lock while calling cancel)
    for id in ids {
        let tok_opt = {
            let reg = __nex_registry().lock().expect("NEX runtime: TASK_REGISTRY mutex poisoned");
            reg.get(&id).map(|m| m.token.clone())
        };
        if let Some(tok) = tok_opt { tok.cancel(); }
    }
}

fn __nex_cancel_children_subtree(parent: __NexTaskId) {
    let ids = __nex_collect_children_subtree_postorder(parent);
    for id in ids {
        let tok_opt = {
            let reg = __nex_registry().lock().expect("NEX runtime: TASK_REGISTRY mutex poisoned");
            reg.get(&id).map(|m| m.token.clone())
        };
        if let Some(tok) = tok_opt { tok.cancel(); }
    }
}

fn __nex_join_subtree(root: __NexTaskId) {
    let ids = __nex_collect_subtree_postorder(root);
    for id in ids {
        let handle_opt = {
            let mut reg = __nex_registry().lock().expect("NEX runtime: TASK_REGISTRY mutex poisoned");
            reg.get_mut(&id).and_then(|m| m.handle.take())
        };
        if let Some(h) = handle_opt { let _ = h.join(); }
    }
}

fn __nex_join_children_subtree(parent: __NexTaskId) {
    let ids = __nex_collect_children_subtree_postorder(parent);
    for id in ids {
        let handle_opt = {
            let mut reg = __nex_registry().lock().expect("NEX runtime: TASK_REGISTRY mutex poisoned");
            reg.get_mut(&id).and_then(|m| m.handle.take())
        };
        if let Some(h) = handle_opt { let _ = h.join(); }
    }
}

fn __nex_spawn_child<F>(f: F) -> __NexTask
where
    F: FnOnce() + Send + 'static,
{
    let _root = __NEX_ROOT_TOKEN.get_or_init(__NexCancelToken::new).clone();
    let parent_id = __nex_get_current_task_id();
    let child_id = __NEX_TASK_ID_GEN.fetch_add(1, Ordering::SeqCst);
    let child_token = __NexCancelToken::new();
    let tok_for_thread = child_token.clone();
    {
        let mut reg = __nex_registry().lock().expect("NEX runtime: TASK_REGISTRY mutex poisoned");
        reg.entry(parent_id).or_insert(__NexTaskMeta { parent: None, children: Vec::new(), token: __NexCancelToken::new(), handle: None });
        reg.insert(child_id, __NexTaskMeta { parent: Some(parent_id), children: Vec::new(), token: child_token.clone(), handle: None });
        if let Some(p) = reg.get_mut(&parent_id) { p.children.push(child_id); }
    }
    let handle = std::thread::spawn(move || {
        __nex_set_current_task_id(child_id);
        __nex_set_current_token(tok_for_thread);
        let _scope = __NexTaskScopeGuard::new(child_id);
        f();
    });
    {
        let mut reg = __nex_registry().lock().expect("NEX runtime: TASK_REGISTRY mutex poisoned");
        if let Some(m) = reg.get_mut(&child_id) { m.handle = Some(handle); }
    }
    __NexTask { id: child_id }
}

fn __nex_join(task: __NexTask) { __nex_join_subtree(task.id); }
fn __nex_cancel(task: &__NexTask) { __nex_cancel_subtree(task.id); }

fn __nex_print(s: &str) { println!("{}", s); }

fn __nex_sleep_ms(ms: i64) {
    std::thread::sleep(Duration::from_millis(ms.max(0) as u64));
}

fn __nex_read_file(path: &str) -> String {
    if !__nex_fs_read_allowed(path) { panic!("NEX runtime: fs.read not allowed: {}", path); }
    let p = Path::new("sandbox_data").join(path);
    fs::read_to_string(p).unwrap_or_else(|_| "".to_string())
}

fn __nex_listen_http(port: i64) {
    if !__nex_net_listen_allowed(port) { panic!("NEX runtime: net.listen not allowed: {}", port); }
    println!("(V1 stub) listening on port {}", port);
}

fn leaf() -> bool {
    loop {
        if __nex_cancelled() {
            __nex_print(&String::from("leaf_cancelled"));
            return true;
        }
        __nex_sleep_ms(10);
    }
    return true;
}

fn worker() -> bool {
    let mut x = __nex_spawn_child(|| {
    leaf();
});
    __nex_sleep_ms(20);
    __nex_cancel(&x);
    __nex_join(x);
    return true;
}

fn __nex_user_main() -> bool {
    let mut t = __nex_spawn_child(|| {
    worker();
});
    __nex_join(t);
    __nex_print(&String::from("done"));
    return true;
}

fn main() {
    __nex_install_root_task_context();
    let _root_scope = __NexTaskScopeGuard::new(__nex_get_current_task_id());
    let _ = __nex_user_main();
}
